import DocsNav from '../DocsNav';

<DocsNav />

# Часть 1. Архитектура и реализация веб-приложений на Flask

Конспект для дисциплины «Проектирование и дизайн информационных систем».

---

## 1. Архитектура веб-приложений и REST-подход

Клиент–серверная модель: клиент (браузер, SPA или мобильное приложение) формирует HTTP‑запрос, сервер выполняет бизнес-логику и возвращает ответ (HTML или JSON).

### Основные HTTP-методы

- `GET` — чтение данных;
- `POST` — создание ресурса;
- `PUT` / `PATCH` — изменение ресурса;
- `DELETE` — удаление ресурса.

### Коды статуса

- `200 OK`
- `201 Created`
- `400 Bad Request`
- `401 Unauthorized`
- `403 Forbidden`
- `404 Not Found`
- `500 Internal Server Error` и другие.

### REST‑принципы

- Ресурсы доступны по предсказуемым URL (например, `/users`).
- Сервер не хранит состояние между запросами (**stateless**).
- Данные обычно передаются в формате JSON.
- Коды ответов стандартизированы и предсказуемы.

Примеры REST‑запросов и ответов:

```http
GET /api/users       → 200 OK, body: [ ... ]
POST /api/users      → 201 Created, Location: /api/users/123
PATCH /api/users/123 → 200 OK
DELETE /api/users/123 → 204 No Content
```

---

## 2. Структура проекта на Flask

Пример структуры:

```text
/project
├── app.py              # точка входа (create_app)
├── config.py           # конфигурация и переменные окружения
├── /routes/            # маршруты/контроллеры (Blueprints)
├── /models/            # ORM‑модели (SQLAlchemy)
├── /services/          # бизнес‑логика
├── /repositories/      # слой доступа к данным
├── /templates/         # Jinja2‑шаблоны
├── /static/            # CSS/JS/изображения
└── requirements.txt    # зависимости
```

Кратко по слоям:

- **Routes** — сопоставляют URL с обработчиками.
- **Templates** — генерация HTML с помощью Jinja2.
- **Models** — описание таблиц и связей БД.
- **Config** — ключи, строки подключения, режимы (development/production).

---

## 3. Основы реляционных баз данных

- Данные хранятся в **таблицах**: строки (записи), столбцы (поля).
- У каждого поля есть **тип данных**.
- **PK (Primary Key)** — первичный ключ, уникально идентифицирует запись.
- **FK (Foreign Key)** — внешний ключ, обеспечивает целостность связей.
- **Индексы** ускоряют поиск и операции соединения (`JOIN`).
- **Ограничения (constraints)**:
  - `NOT NULL`
  - `UNIQUE`
  - `CHECK`
  - `FOREIGN KEY`

Типичные связи:

- **1‑ко‑многим** — например, `User → Orders`;
- **многие‑ко‑многим** — например, `Students ↔ Courses`.

---

## 4. Язык SQL — основные операции

Примеры базовых операций:

```sql
-- выборка
SELECT id, name, email
FROM users
WHERE active = 1
ORDER BY name;

-- добавление
INSERT INTO users (name, email)
VALUES ('Ivan', 'ivan@mail.ru');

-- изменение
UPDATE users
SET email = 'iv.new@mail.ru'
WHERE id = 1;

-- удаление
DELETE FROM users
WHERE id = 1;
```

Часто используются также:

- соединения (`JOIN`);
- группировка (`GROUP BY`);
- агрегатные функции (`COUNT`, `SUM`, `AVG`, и т.п.);
- подзапросы.

---

## 5. ORM и SQLAlchemy

ORM (Object‑Relational Mapping) сопоставляет таблицы БД с Python‑классами. Разработчик работает с объектами, а SQL‑запросы генерируются автоматически.

```python
# models/user.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()


class User(db.Model):
    __tablename__ = "users"

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)

    orders = db.relationship("Order", backref="user", lazy="select")


class Order(db.Model):
    __tablename__ = "orders"

    id = db.Column(db.Integer, primary_key=True)
    total = db.Column(db.Numeric(10, 2), nullable=False, default=0)
    user_id = db.Column(db.Integer, db.ForeignKey("users.id"), nullable=False)
```

Создание записи:

```python
u = User(name="Ivan", email="ivan@mail.ru")
db.session.add(u)
db.session.commit()
```

Выборка с фильтрами:

```python
users = (
    User.query
    .filter(User.name.ilike("%iv%"))
    .order_by(User.name)
    .all()
)
```

---

## 6. Подключение к СУБД MySQL

Секреты рекомендуется хранить в переменных окружения (`.env`). В качестве драйвера используется `PyMySQL`.

```python
# config.py
import os


class Config:
    SQLALCHEMY_DATABASE_URI = (
        f"mysql+pymysql://{os.getenv('DB_USER')}:{os.getenv('DB_PASS')}"
        f"@{os.getenv('DB_HOST', '127.0.0.1')}:{os.getenv('DB_PORT', '3306')}"
        f"/{os.getenv('DB_NAME')}"
    )
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SECRET_KEY = os.getenv("SECRET_KEY", "dev-secret")
```

```python
# app.py
from flask import Flask
from models.user import db
from config import Config


def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    db.init_app(app)
    with app.app_context():
        db.create_all()

    return app


app = create_app()
```

---

## 7. CRUD‑операции во Flask

```python
# routes/users.py
from flask import Blueprint, request, jsonify
from models.user import db, User

bp = Blueprint("users", __name__, url_prefix="/api/users")


@bp.post("")
def create_user():
    data = request.get_json()
    u = User(name=data["name"], email=data["email"])
    db.session.add(u)
    db.session.commit()
    return jsonify({"id": u.id}), 201


@bp.get("")
def list_users():
    users = User.query.order_by(User.name).all()
    return jsonify([
        {"id": u.id, "name": u.name, "email": u.email}
        for u in users
    ])
```

---

## 8. Аутентификация и авторизация

- **Аутентификация** — проверка личности (логин/пароль, токены).
- **Авторизация** — проверка прав (роли, разрешения).

Пароли **нельзя** хранить в открытом виде — только в виде хэша.

```python
from werkzeug.security import generate_password_hash, check_password_hash

u.password_hash = generate_password_hash(plain_password)

check_password_hash(u.password_hash, entered_password)  # → True / False
```

- Для API часто применяются JWT‑токены.
- Для серверных шаблонов — сессии Flask (например, с `Flask-Login`).

---

## 9. Шаблоны проектирования (View–Service–Repository)

Структура приложения по слоям:

- **View** — обработка входящих и исходящих данных (Blueprints, Jinja2‑шаблоны).
- **Service** — бизнес‑правила, валидации, работа с транзакциями.
- **Repository** — обращение к БД через ORM или «сырые» SQL‑запросы.

Преимущества:

- снижение связанности;
- упрощение тестирования и сопровождения;
- чёткое разделение ответственности;
- повторное использование логики (service/repository можно вызывать из разных views).

---

## 10. Требования к безопасности

- Включить **CSRF‑защиту** для форм (например, с помощью `Flask-WTF`).
- Экранировать пользовательский ввод (Jinja2 делает это по умолчанию).
- Защищаться от XSS и SQL‑инъекций:
  - использовать ORM или параметризованные запросы;
  - избегать конкатенации SQL‑строк.
- Использовать **HTTPS**.
- Настраивать куки с флагами `HttpOnly`, `Secure`.
- Ограничивать максимальный размер запросов (особенно upload).
- Обновлять зависимости, использовать линтеры безопасности и анализ зависимостей (SCA).

Пример формы с CSRF:

```html
<form method="post">
  {{ form.csrf_token }}
  ...
</form>
```

---

## 11. Принципы построения панелей администратора

- Структуры отображения данных:
  - списки/таблицы,
  - карточки,
  - детальные страницы.
- Инструменты:
  - поиск,
  - быстрые фильтры,
  - сортировка,
  - пагинация,
  - экспорт (CSV/Excel).
- CRUD‑операции с подтверждением действий (модальные окна, toast‑уведомления).
- Управление пользователями и ролями.
- Журналирование действий (логирование).

Требования к UX:

- понятная навигация;
- доступность;
- горячие клавиши;
- достаточный контраст.

Возможные инструменты:

- Flask‑Admin;
- Bootstrap;
- DataTables;
- WTForms.

---